# 1C-Matrix

## Как этим пользоваться?
Морфеус или клиент запускается с помощью `python3 morfeus.py` или `python3 client.py` соответственно.
### Инструкция для Морфеуса:
1. Задаём хост, порт и количество желаемых клиентов, например, с помощью команды `localhost 8080 2` (запускаемся на ('localhost', 8080), поддерживаем двух клиентов).
2. Ждём, пока подключатся все клиенты. Всё это время нам приходят уведомления вида `Connected:  ('127.0.0.1', 53574)`.
3. Когда все клиенты подключились, можем с ними переписываться. Можно: \
   а) Вывести список всех клиентов с помощью команды `GL` (от "Get List").
   б) Отправить приватное сообщение командой вида `MP index msg` (от "Message Private"), где index - индекс получателя в списке клиентов.
   в) Отправить broadcast-сообщение командой вида `MB msg` (от "Message Broadcast").
4. Когда захотим завершить сессию, смело пишем команду `E` (от "Exit").
### Инструкция для клиента:
1. Подключаемся к Морфеусу с помощью команды `R host port`, где `host` и `port` - известный нам адрес Морфеуса.
2. Ждём сообщений от него. Когда приходит сообщение, можем либо написать `M msg`, чтобы ответить, либо написать `S`, чтобы показать, что отвечать на сообщение не хотим. Вне зависимости от вида сообщения (приватное или broadcast) взаимодействие с клиентом одинаковое. \
Пример такого взаимодействия: <img width="284" alt="Снимок экрана 2023-10-17 в 23 49 51" src="https://github.com/el-manz/1C-Matrix/assets/83511476/cfb033b6-3588-4f35-b70e-139c7512d5e1"> \
В это время Морфеусу приходит "уведомление", в котором отображается либо ответ клиента, либо сообщение о том, что ответа нет ("No response").

## Как это работает?
1. Взаимодействие Морфеуса и клиентов происходит при помощи модуля `socket` в Python.
2. Для интеракции с пользователем я использовала своего рода "детерминированный конечный автомат", где состояния отвечали за то, что мы ждём от пользователя в данный конкретный момент.

## Чего не хватает моей реализации и что можно улучшать?
